
-- inserir estadia apartir de uma reserva confirmada
CREATE OR REPLACE FUNCTION sincronizar_estadia_com_reserva()
RETURNS TRIGGER AS $$
	BEGIN
    -- Quando a reserva é confirmada
    IF NEW.status = 'confirmada' THEN
            INSERT INTO Estadia (
                data_checkin,
                data_checkout,
                cliente_id,
                quarto_id,
                reserva_id
            )
            VALUES (
                NEW.data_checkin_prevista,
                NEW.data_checkout_previsto,
                NEW.cliente_id,
                NEW.quarto_id,
                NEW.id
            );
	END IF;	

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
	
-- drop function sincronizar_estadia_com_reserva cascade
CREATE TRIGGER trg_sincronizar_estadia
AFTER INSERT OR UPDATE ON Reserva
FOR EACH ROW
EXECUTE FUNCTION sincronizar_estadia_com_reserva();

-- verificar disponibilidade do quarto no periodo solicitado
-- drop function verificar_disponibilidade_quarto cascade;

CREATE OR REPLACE FUNCTION verificar_disponibilidade_quarto()
RETURNS TRIGGER AS $$
	DECLARE
	    quarto_ocupado BOOLEAN;
		num_quarto INTEGER;
		hotel_name TEXT;
	BEGIN
		Select h.nome from hotel h where h.id = new.hotel_id into hotel_name;
		select q.numero from quarto q where q.id = new.quarto_id into num_quarto; 
	    -- Verifica se o quarto específico está disponível no período solicitado
	    SELECT EXISTS (
	        SELECT 1
	        FROM Reserva r
	        WHERE r.hotel_id = NEW.hotel_id
	          AND r.quarto_id = NEW.quarto_id
	          AND r.status = 'confirmada'
	          AND r.id != COALESCE(NEW.id, 0)  -- Ignora a própria reserva em caso de UPDATE
	          AND (
	              -- Verifica se há sobreposição de datas:
	              -- 1. O check-in da nova reserva ocorre durante uma reserva existente
	              (NEW.data_checkin_prevista >= r.data_checkin_prevista AND 
	               NEW.data_checkin_prevista < r.data_checkout_previsto)
	              OR
	              -- 2. O check-out da nova reserva ocorre durante uma reserva existente
	              (NEW.data_checkout_previsto > r.data_checkin_prevista AND 
	               NEW.data_checkout_previsto <= r.data_checkout_previsto)
	              OR
	              -- 3. A nova reserva engloba completamente uma reserva existente
	              (NEW.data_checkin_prevista <= r.data_checkin_prevista AND 
	               NEW.data_checkout_previsto >= r.data_checkout_previsto)
	          )
	    ) INTO quarto_ocupado;
	
	    -- Se o quarto estiver ocupado no período, rejeitar a reserva
	    IF quarto_ocupado THEN
	        RAISE EXCEPTION 'O quarto % do hotel % não está disponível para o período de % a %', 
	                        num_quarto, hotel_name, 
	                        NEW.data_checkin_prevista, NEW.data_checkout_previsto;
	    END IF;
	
	    -- Verificar se o tipo de quarto solicitado corresponde ao quarto escolhido
	    PERFORM 1
	    FROM Quarto q
	    WHERE q.id = NEW.quarto_id
	      AND q.hotel_id = NEW.hotel_id
	      AND q.tipo_quarto_id = NEW.tipo_quarto_id;
	    
	    IF NOT FOUND THEN
	        RAISE EXCEPTION 'O quarto % do hotel % não é do tipo %', 
	                        NEW.quarto_id, NEW.hotel_id, NEW.tipo_quarto_id;
	    END IF;
	
	    -- Se chegou aqui, o quarto está disponível
	    RETURN NEW;
	END;
$$ LANGUAGE plpgsql;
	

CREATE TRIGGER trg_verificar_disponibilidade_quarto
BEFORE INSERT OR UPDATE ON Reserva
FOR EACH ROW
EXECUTE FUNCTION verificar_disponibilidade_quarto();

-- calcular valor total da reserva
CREATE OR REPLACE FUNCTION calcular_valor_reserva()
RETURNS TRIGGER AS $$
DECLARE
    preco_base NUMERIC(10,2);
    andar_quarto INT;
    dias_estadia INT;
    fator_andar NUMERIC := 1.0;
BEGIN
    -- Obter o preço da diária
    SELECT preco_noite INTO preco_base
    FROM Tipo_Quarto q
    WHERE q.id = NEW.tipo_quarto_id and hotel_id = new.hotel_id;

    -- Obter o andar do quarto
    SELECT andar INTO andar_quarto
    FROM Quarto q
    WHERE q.id = NEW.quarto_id AND hotel_id = NEW.hotel_id;

    -- Calcular dias da estadia (data_checkout - data_checkin)
    dias_estadia := GREATEST(NEW.data_checkout_previsto - NEW.data_checkin_prevista, 1);

    -- Calcular fator de aumento por andar acima do primeiro
    IF andar_quarto > 1 THEN
        fator_andar := 1 + 0.1 * (andar_quarto - 1);
    END IF;

    -- Calcular o valor final
    NEW.valor := preco_base * dias_estadia * fator_andar;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_calcular_valor_reserva
BEFORE INSERT OR UPDATE ON Reserva
FOR EACH ROW
EXECUTE FUNCTION calcular_valor_reserva();


-- validar periodo de checkIn e checkOut

CREATE OR REPLACE FUNCTION validar_periodo_reserva()
RETURNS TRIGGER AS $$

BEGIN
    IF NEW.data_checkout_previsto <= NEW.data_checkin_prevista THEN
        RAISE EXCEPTION 'A data de check-out (%) deve ser posterior à data de check-in (%)',
                         NEW.data_checkout_previsto, NEW.data_checkin_prevista;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_validar_periodo_reserva
BEFORE INSERT OR UPDATE ON Reserva
FOR EACH ROW
EXECUTE FUNCTION validar_periodo_reserva();

CREATE OR REPLACE FUNCTION roombyhotelid(id_hot)
RETURNS Table(
        id bigint,
        andar int,
        numero numeric,
        hotel_id bigint,
        tipo_quarto_id bigint,
        plano varchar,
        preco_noite numeric(10,2),
        tp_quarto varchar
        ) AS $$
		begin
			RETURN QUERY
			    SELECT q.*, tq.plano,tq.preco_noite, tq.tp_quarto FROM quarto q 
			    JOIN tipo_quarto tq ON tq.id = q.tipo_quarto_id
			    WHERE q.hotel_id = id_hot;
		end;
	
